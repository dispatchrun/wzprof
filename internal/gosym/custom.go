package gosym

// In this package, the two files pclntab.go and symtab.go have been copied
// verbatim from the golang/go/debug/gosym directory. This file contains code
// that exports additional information needed to perform the go stack unwinding.

// https://github.com/golang/go/blob/b950cc8f11dc31cc9f6cfbed883818a7aa3abe94/src/internal/abi/symtab.go#L8

// A FuncFlag records bits about a function, passed to the runtime.
type FuncFlag uint8

const (
	// FuncFlagTopFrame indicates a function that appears at the top of its stack.
	// The traceback routine stop at such a function and consider that a
	// successful, complete traversal of the stack.
	// Examples of TopFrame functions include goexit, which appears
	// at the top of a user goroutine stack, and mstart, which appears
	// at the top of a system goroutine stack.
	FuncFlagTopFrame FuncFlag = 1 << iota

	// FuncFlagSPWrite indicates a function that writes an arbitrary value to SP
	// (any write other than adding or subtracting a constant amount).
	// The traceback routines cannot encode such changes into the
	// pcsp tables, so the function traceback cannot safely unwind past
	// SPWrite functions. Stopping at an SPWrite function is considered
	// to be an incomplete unwinding of the stack. In certain contexts
	// (in particular garbage collector stack scans) that is a fatal error.
	FuncFlagSPWrite

	// FuncFlagAsm indicates that a function was implemented in assembly.
	FuncFlagAsm
)

type FuncID uint8

// https://github.com/golang/go/blob/b950cc8f11dc31cc9f6cfbed883818a7aa3abe94/src/internal/abi/symtab.go#L8
const (
	// If you add a FuncID, you probably also want to add an entry to the map in
	// ../../cmd/internal/objabi/funcid.go

	FuncIDNormal FuncID = iota // not a special function
	FuncID_abort
	FuncID_asmcgocall
	FuncID_asyncPreempt
	FuncID_cgocallback
	FuncID_debugCallV2
	FuncID_gcBgMarkWorker
	FuncID_goexit
	FuncID_gogo
	FuncID_gopanic
	FuncID_handleAsyncEvent
	FuncID_mcall
	FuncID_morestack
	FuncID_mstart
	FuncID_panicwrap
	FuncID_rt0_go
	FuncID_runfinq
	FuncID_runtime_main
	FuncID_sigpanic
	FuncID_systemstack
	FuncID_systemstack_switch
	FuncIDWrapper // any autogenerated code (hash/eq algorithms, method wrappers, etc.)
)

type RuntimeInfo struct {
	funcs []FuncInfo
	Pctab []byte
}

func (r RuntimeInfo) FindFunc(pc uint64) *FuncInfo {
	start := 0
	end := len(r.funcs)
	for start <= end {
		m := (end-start)/2 + start
		switch {
		case pc < r.funcs[m].Entry:
			end = m
		case r.funcs[m].Entry <= pc && pc < r.funcs[m].End:
			return &r.funcs[m]
		default:
			start = m + 1
		}
	}
	return nil
}

// Copy of _func in runtime/runtime2.go.
type FuncInfo struct {
	// EntryOff
	// NameOff
	Args        int32
	Deferreturn uint32
	Pcsp        uint32
	// Pcfile
	// Pcln
	// Npcdata
	// CuOffset
	// StartLine
	FuncID FuncID
	Flag   FuncFlag

	Entry uint64
	End   uint64
}

func (f *FuncInfo) Valid() bool {
	return f != nil
}

func (t *LineTable) RuntimeInfo() RuntimeInfo {
	// based on go12Funcs
	ft := t.funcTab()
	funcs := make([]FuncInfo, ft.Count())
	for i := range funcs {
		funcs[i] = t.funcInfo(uint32(i))
		funcs[i].Entry = ft.pc(i)
		funcs[i].End = ft.pc(i + 1)
	}
	return RuntimeInfo{funcs: funcs, Pctab: t.pctab}
}

// mix of funcData + field to fully reconstruct the i-th func object (because we
// want more than 9 fields, and they are not all the same size.
func (t *LineTable) funcInfo(i uint32) FuncInfo {
	data := t.funcdata[t.funcTab().funcOff(int(i)):]
	// type _func struct {
	// 	entryOff uint32        // 0
	// 	nameOff  int32         // 4
	//
	// 	args        int32      // 8
	// 	deferreturn uint32     // 12
	//
	// 	pcsp      uint32       // 16
	// 	pcfile    uint32       // 20
	// 	pcln      uint32       // 24
	// 	npcdata   uint32       // 28
	// 	cuOffset  uint32       // 32
	// 	startLine int32        // 36
	// 	funcID    abi.FuncID   // 40 - 1 byte
	// 	flag      abi.FuncFlag // 41 - 1 byte
	//
	//      // ... more
	// }

	return FuncInfo{
		Args:        int32(t.binary.Uint32(data[8:])),
		Deferreturn: t.binary.Uint32(data[12:]),
		Pcsp:        t.binary.Uint32(data[16:]),
		FuncID:      FuncID(data[40]),
		Flag:        FuncFlag(data[41]),
	}
}
