//go:build (linux || darwin) && (amd64 || arm64)

package gosym

import (
	"encoding/binary"
	"unsafe"
)

// In this package, the two files pclntab.go and symtab.go have been copied
// verbatim from the golang/go/debug/gosym directory. This file contains code
// that exports additional information needed to perform the go stack unwinding.
//
// This code makes assumption that the machine running it is 64bits
// little-endian, so that it can directly interpret the data structure emitted
// by the go compiler generating code for the wasm architecture.

// https://github.com/golang/go/blob/b950cc8f11dc31cc9f6cfbed883818a7aa3abe94/src/internal/abi/symtab.go#L8

// A FuncFlag records bits about a function, passed to the runtime.
type FuncFlag uint8

const (
	// FuncFlagTopFrame indicates a function that appears at the top of its stack.
	// The traceback routine stop at such a function and consider that a
	// successful, complete traversal of the stack.
	// Examples of TopFrame functions include goexit, which appears
	// at the top of a user goroutine stack, and mstart, which appears
	// at the top of a system goroutine stack.
	FuncFlagTopFrame FuncFlag = 1 << iota

	// FuncFlagSPWrite indicates a function that writes an arbitrary value to SP
	// (any write other than adding or subtracting a constant amount).
	// The traceback routines cannot encode such changes into the
	// pcsp tables, so the function traceback cannot safely unwind past
	// SPWrite functions. Stopping at an SPWrite function is considered
	// to be an incomplete unwinding of the stack. In certain contexts
	// (in particular garbage collector stack scans) that is a fatal error.
	FuncFlagSPWrite

	// FuncFlagAsm indicates that a function was implemented in assembly.
	FuncFlagAsm
)

type FuncID uint8

// https://github.com/golang/go/blob/b950cc8f11dc31cc9f6cfbed883818a7aa3abe94/src/internal/abi/symtab.go#L8
const (
	// If you add a FuncID, you probably also want to add an entry to the map in
	// ../../cmd/internal/objabi/funcid.go

	FuncIDNormal FuncID = iota // not a special function
	FuncID_abort
	FuncID_asmcgocall
	FuncID_asyncPreempt
	FuncID_cgocallback
	FuncID_debugCallV2
	FuncID_gcBgMarkWorker
	FuncID_goexit
	FuncID_gogo
	FuncID_gopanic
	FuncID_handleAsyncEvent
	FuncID_mcall
	FuncID_morestack
	FuncID_mstart
	FuncID_panicwrap
	FuncID_rt0_go
	FuncID_runfinq
	FuncID_runtime_main
	FuncID_sigpanic
	FuncID_systemstack
	FuncID_systemstack_switch
	FuncIDWrapper // any autogenerated code (hash/eq algorithms, method wrappers, etc.)
)

const (
	PCDATA_UnsafePoint   = 0
	PCDATA_StackMapIndex = 1
	PCDATA_InlTreeIndex  = 2
	PCDATA_ArgLiveIndex  = 3

	FUNCDATA_ArgsPointerMaps    = 0
	FUNCDATA_LocalsPointerMaps  = 1
	FUNCDATA_StackObjects       = 2
	FUNCDATA_InlTree            = 3
	FUNCDATA_OpenCodedDeferInfo = 4
	FUNCDATA_ArgInfo            = 5
	FUNCDATA_ArgLiveInfo        = 6
	FUNCDATA_WrapInfo           = 7
)

type RuntimeInfo struct {
	funcs []FuncInfo
	Pctab []byte
}

func (r RuntimeInfo) FindFunc(pc uint64) *FuncInfo {
	start := 0
	end := len(r.funcs)
	for start <= end {
		m := (end-start)/2 + start
		switch {
		case pc < r.funcs[m].Entry:
			end = m
		case r.funcs[m].Entry <= pc && pc < r.funcs[m].End:
			return &r.funcs[m]
		default:
			start = m + 1
		}
	}
	return nil
}

// Copy of _func in runtime/runtime2.go. It has to have the same size.
type _Func struct {
	EntryOff    uint32 // start pc, as offset from moduledata.text/pcHeader.textStart
	NameOff     int32  // function name, as index into moduledata.funcnametab.
	Args        int32  // in/out args size
	Deferreturn uint32 // offset of start of a deferreturn call instruction from entry, if any.
	Pcsp        uint32
	Pcfile      uint32
	Pcln        uint32
	Npcdata     uint32
	CuOffset    uint32 // runtime.cutab offset of this function's CU
	StartLine   int32  // line number of start of function (func keyword/TEXT directive)
	FuncID      FuncID
	Flag        FuncFlag
	_           [1]byte // pad
	Nfuncdata   uint8
}

type FuncInfo struct {
	_Func
	Data  []byte
	Entry uint64
	End   uint64

	// TODO: for debug, remove me
	Name string
	Idx  int
}

func (f *FuncInfo) Valid() bool {
	return f != nil
}

func (f *FuncInfo) SrcFunc() SrcFunc {
	if !f.Valid() {
		return SrcFunc{}
	}
	return SrcFunc{f._Func.NameOff, f._Func.StartLine, f._Func.FuncID}
}

// A SrcFunc represents a logical function in the source code. This may
// correspond to an actual symbol in the binary text, or it may correspond to a
// source function that has been inlined.
type SrcFunc struct {
	// datap     *moduledata
	NameOff   int32
	StartLine int32
	FuncID    FuncID
}

// Returns the offset in moduledata.pctab for the i-th pcdata table of f.
// (also known as pcdatastart in runtime/symtab.go)
func (f *FuncInfo) PcdataOffset(table uint32) uint32 {
	o := uint64(unsafe.Sizeof(_Func{})) + uint64(table)*4
	return binary.LittleEndian.Uint32(f.Data[o:])
}

// Returns the offset from moduledata.gofunc for the i-th funcdata of f.
func (f *FuncInfo) FuncDataOffset(i uint8) uint32 {
	o := uint64(unsafe.Sizeof(_Func{})) + uint64(f.Npcdata*4) + uint64(i)*4
	return binary.LittleEndian.Uint32(f.Data[o:])
}

func (t *LineTable) RuntimeInfo() RuntimeInfo {
	ft := t.funcTab()
	funcs := make([]FuncInfo, ft.Count())
	for i := range funcs {
		data := t.funcdata[t.funcTab().funcOff(i):]
		_f := (*_Func)(unsafe.Pointer(unsafe.SliceData(data)))
		funcs[i] = FuncInfo{
			_Func: *_f,
			Data:  data,
			Entry: ft.pc(i),
			End:   ft.pc(i + 1),

			Name: ft.funcName(uint32(_f.NameOff)),
			Idx:  i,
		}
	}
	return RuntimeInfo{funcs: funcs, Pctab: t.pctab}
}
